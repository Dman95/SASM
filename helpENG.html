<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<meta content="text/html; charset=utf-8" http-equiv="content-type">
	<TITLE>SASM help</TITLE>
</HEAD>
<BODY>
<H1>Brief help.</H1>
<P>
SASM (SimpleASM) - simple Open Source crossplatform IDE for NASM assembly language.
</P>
<P>
In SASM you can easily develop and execute programs, written in NASM assembly language. Enter code in form and simply run your program. Enter your input data in "Input" docking field. In "Output" field you can see the result of the execution of the program. Wherein all messages and compilation errors will be shown in the form on the bottom. You can save source or already compiled (exe) code of your program to file and load your programs from file.
</P>
<P>
SASM supports working with many opened projects – new files are opened and created in new tabs. At the exit from SASM current set of opened files saved. At the next start you can restore previous session. In settings you can set font, color scheme and initial text. SASM is translated into Russian and English. All dialog windows in SASM is docking - you can choose one of many variants of their position.
</P>
<P>
Standard "Edit" menu extended with abilities to comment/uncomment piece of source code and to create/delete indent with 4 spaces (Tab/Shift+Tab).
</P>
<P>
Starting with version 2.2 it is possible to reassign the hotkeys. File with them located on the path "Linux/share/sasm/keys.ini" ("/usr/share/sasm/keys.ini" if SASM was installed) in Linux and on the path "Windows/keys.ini" in Windows.
</P>
<P>
&nbsp;
</P>
<H3>"io.inc" macro library</H3>
<P>
SASM includes crossplatform input/output library "io.inc". It contains I/O macro and 2 additional macro: CMAIN - entry point and CEXTERN for invoking functions, located in C language libraries ("CEXTERN printf" for example).
<P>
&nbsp;
</P>
</P>
<table border="0" cellspacing="0" cellpadding="0">
<thead>
<tr>
<td width="242">Macro name</td>
<td width="390">Description</td>
</tr>
</thead>
<tbody>
<tr>
<td width="242" valign="top"><a name="PRINT_UDEC">PRINT_UDEC</a> <em>size, data</em></p>
<p><a name="PRINT_DEC">PRINT_DEC</a><em> size, data</em></td>
<td width="390" valign="top">Print number <em>data</em> in decimal representation. <em>size</em> – number, giving size of <em>data</em> in bytes - 1, 2 or 4.
<em>data</em> must be number or symbol constant, name of variable, register or address expression without size qualifier (byte[], etc.). PRINT_UDEC print number as unsigned, PRINT_DEC — as signed.</td>
</tr>
<tr>
<td width="242" valign="top"><a name="PRINT_HEX">PRINT_HEX</a> <em>size, data</em></td>
<td width="390" valign="top">Similarly previous, but data is printed in hexadecimal representation.</td>
</tr>
<tr>
<td width="242" valign="top"><a name="PRINT_CHAR">PRINT_CHAR</a> <em>ch</em></td>
<td width="390" valign="top">Print symbol <em>ch</em>. <em>ch</em> - number or symbol constant, name of variable, register or address expression without size qualifier (byte[], etc.).</td>
</tr>
<tr>
<td width="242" valign="top"><a name="PRINT_STRING">PRINT_STRING</a> <em>data</em></td>
<td width="390" valign="top">Print null-terminated text string. <em>data</em> - string constant, name of variable or address expression without size qualifier (byte[], etc.).</td>
</tr>
<tr>
<td width="242" valign="top"><a name="NEWLINE">NEWLINE</a></td>
<td width="390" valign="top">Print newline ('\n').</td>
</tr>
<tr>
<td width="242" valign="top"><a name="GET_UDEC">GET_UDEC</a> <em>size</em>, <em>data</em></p>
<p><a name="GET_DEC">GET_DEC</a> <em>size</em>, <em>data</em></td>
<td width="390" valign="top">Input number data in decimal representation from stdin. <em>size</em> – number, giving size of <em>data</em> in bytes - 1, 2 or 4. <em>data</em> must be name of variable or register or address expression without size qualifier (byte[], etc.). GET_UDEC input number as unsigned, GET_DEC — as signed. It is not allowed to use esp register.</td>
</tr>
<tr>
<td width="242" valign="top"><a name="GET_HEX">GET_HEX</a> <em>size, data</em></td>
<td width="390" valign="top">Similarly previous, but data is entered in hexadecimal representation with 0x prefix.</td>
</tr>
<tr>
<td width="242" valign="top"><a name="GET_CHAR">GET_CHAR</a> <em>data</em></td>
<td width="390" valign="top">Similarly previous, but macro reads one symbol only.</td>
</tr>
<tr>
<td width="242" valign="top"><a name="GET_STRING">GET_STRING</a> <em>data, maxsz</em></td>
<td width="390" valign="top">Input string with length less than <em>maxsz</em>. Reading stoppes on EOF or newline and "\n" writes in buffer. In the end of string  0 character is added to the end. <em>data</em> - name of variable or address expression without size qualifier (byte[], etc.). <em>maxsz</em> - register or number constant.</td>
</tr>
</tbody>
</table>
<P>
&nbsp;
</P>
<H3>A little bit about the debugger:</H3>
<P>
As the debugger SASM used gdb. In the distribution under Windows it included in the package. In Linux, you must install this package.
</P>
<P>
Attention! Before debugging make all functions formed frames (mov ebp, esp). This rule should be done for all functions, including main.
</P>
<P>
To run the debugger click "Debug" item in "Debug" menu or press F5. Now you can debug your program.
</P>
<P>
You can toggle breakpoint, clicking on line number or pressing F8 with cursor on line number, on which you want to suspend your program execution.
<BR>
"Continue" command (F5) continues execution to breakpoint or to the end of your program.
<BR>
"Step into" command (F11) goes to next instruction possible entering functions.
<BR>
"Step over" command (F10) goes to next instruction skipping functions.
<BR>
"Show registers" command (Ctrl+R) shows window with values of CPU registers.
<BR>
"Show memory" command (Ctrl+M) shows window to watch variables or memory on random address. 
Typing name of variable, address or any expression over text "Add variable..." and size (b - byte (1), w - word (2), d - double word (4), q - quad word (8)), in "Value" field you will see value of expression. 
Also you can add variable from code, clicking right mouse button on line with variable and choose "Watch".
In expressions you can use any operator of C language (*, &, +, -, *, /, %, !, >, &, |, &lt;&lt;, sizeof, etc.), registers should have $ prefix ($eax for example). 
If you want to watch memory on address you shold check "Address" checkbox on the right.
Output format is determined in the first drop-down menu (format Smart trying to choose the most suitable type of display).
To watch contents of array specify the number of elements in the array in "array size" field.
To remove watches click right mouse button on it and choose "Delete watch" or press Del button.
In Windows watching variables from .rodata section you should display them as address.
<BR>
Values of registers and expressions refreshes by jumping on next instruction.
</P>
Also when you run the debugger you see "GDB command" widget on the bottom of SASM. With its help you can perform any gdb command pressing Enter key. Commands and their results will be showed in log widget. Previous commands available by pressing up and down keys.
If you press Enter with empty command, last command will be performed. Results of performing commands synchronize with current debugging line highlighting and with state of windows, which shows memory and registers. You can use "Print" option - if it is checked, result of command performing printing immediately ("p" command adds to input) (handy for a quick evaluation of the expression (for example, as a calculator)).
In expressions you can use any operator of C language (*, &, +, -, *, /, %, !, >, &, |, &lt;&lt;, sizeof, etc.), registers should have $ prefix ($eax for example).
For example, if you want to know, what is placed on top of stack, you might enter expression: "*((int *)$esp)" with "Print" checkbox checked or simply enter command "p *((int *)$esp)".
<BR>
To set value to variable or register you shoud enter "p" before assignment operator ("p $eax = 5") or perform assignment in "Print" mode (if "Print" checkbox is checked).
<BR>
Also you can enter "help" command in "GDB command" field to show gdb commands help.
<P>&nbsp;</P>
<H3>Implementation:</H3>
<H4>Windows</H4>
<P>As NASM compiler used nasm 2.10.05, run under Cygwin included in SASM, as linker - gcc 4.6.2. Also SASM contains gdb debugger from MinGW and "io.inc" macro library. On Windows SASM is ready for work immediately after installation.</P>
<H4>Linux</H4>
<P>
For correct working on Linux must be installed next packages: nasm, gcc, gdb (for debugging).</P>
<P>&nbsp;</P>
<H3>Warnings:</H3>
<P>
<B>
If you have something does not work, check the following items:
</B>
</P>
<P STYLE="margin-left: 0.5in; text-indent: -0.25in">1)<SPAN STYLE="font-variant: normal">&nbsp;&nbsp;&nbsp;
Program enter point should be marked with global label _main (in Windows) or main (in Linux) or CMAIN from "io.inc" (see initial text).
</P>
<P STYLE="margin-left: 0.5in; text-indent: -0.25in">2)<SPAN STYLE="font-variant: normal">&nbsp;&nbsp;&nbsp;
Before debugging make all functions formed frames (mov ebp, esp). This rule should be done for all functions, including main.
if this condition is not met, the correct work of the debugger is not guaranteed.
</P>
<P STYLE="margin-left: 0.5in; text-indent: -0.25in">3)<SPAN STYLE="font-variant: normal">&nbsp;&nbsp;&nbsp;
If something still does not work, but worked before, try to use the "Reset all" button in the settings on the "Common" tab.
</P>
<P>&nbsp;</P>
<P>
Wishes and reports send to e-mail: <a href="mailto:Dman1095@gmail.com">Dman1095@gmail.com</a> or left on <a href="https://github.com/Dman95/SASM/issues">GitHub issues</a>.
</P>
<P>
More information and new versions of SASM see on the site: <a href="http://dman95.github.io/SASM/">http://dman95.github.io/SASM/</a>
</P>
</BODY>
</HTML>
